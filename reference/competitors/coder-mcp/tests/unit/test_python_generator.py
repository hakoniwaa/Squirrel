#!/usr/bin/env python3
"""
Unit tests for Python Template Generator
Tests all template generation functionality
"""

from pathlib import Path
from unittest.mock import MagicMock

import pytest

from tests.helpers.test_python_generator_base import PythonGeneratorForTesting


class TestPythonGenerator:
    """Test suite for PythonGenerator class"""

    @pytest.fixture
    def generator(self):
        """Create a PythonGenerator instance with mocked base methods"""
        generator = PythonGeneratorForTesting()

        # Override methods with mocks for testing
        generator.get_source_directory = MagicMock(return_value=Path("/test/src"))
        generator.generate_file_header = MagicMock(return_value="# Generated by coder-mcp\n\n")
        generator.write_file = MagicMock(return_value={"path": "test.py", "size": 100})

        return generator

    def test_language_properties(self, generator):
        """Test basic language property methods"""
        assert generator.get_language_name() == "python"
        assert generator.get_file_extension() == ".py"
        assert generator.get_test_framework() == "pytest"
        assert generator.get_package_manager() == "pip"

    @pytest.mark.asyncio
    async def test_generate_api_endpoint_post_with_auth(self, generator):
        """Test generating a POST endpoint with authentication"""
        options = {"method": "POST", "auth_required": True}

        result = await generator.generate_api_endpoint("User", options)

        # Check that files were created
        assert len(result["created_files"]) == 3
        assert "/test/src/api/user.py" in result["created_files"]
        assert "/test/src/services/user.py" in result["created_files"]
        assert "/test/src/models/user.py" in result["created_files"]

        # Verify next steps are included
        assert len(result["next_steps"]) > 0

        # Verify write_file was called 3 times
        assert generator.write_file.call_count == 3

        # Check the generated content includes auth imports
        api_content = generator.write_file.call_args_list[0][0][1]
        assert "from ..auth import get_current_user" in api_content
        assert "current_user = Depends(get_current_user)" in api_content
        assert "data['created_by_id'] = current_user.id" in api_content

    @pytest.mark.asyncio
    async def test_generate_api_endpoint_get_without_auth(self, generator):
        """Test generating a GET endpoint without authentication"""
        options = {"method": "GET", "auth_required": False}

        await generator.generate_api_endpoint("Product", options)

        # Check the generated content
        api_content = generator.write_file.call_args_list[0][0][1]
        assert "from ..auth import get_current_user" not in api_content
        assert "current_user = Depends(get_current_user)" not in api_content

        # Should have list/filter logic
        assert "filters = request.dict(exclude_unset=True)" in api_content
        assert "results = service.list(filters=filters)" in api_content

    @pytest.mark.asyncio
    async def test_generate_api_endpoint_put_method(self, generator):
        """Test generating a PUT endpoint"""
        options = {"method": "PUT", "auth_required": True}

        await generator.generate_api_endpoint("Order", options)

        api_content = generator.write_file.call_args_list[0][0][1]
        assert "request: OrderRequest," in api_content
        assert "data['updated_by_id'] = current_user.id" in api_content
        assert "result = service.update(resource_id, data)" in api_content

    @pytest.mark.asyncio
    async def test_generate_api_endpoint_includes_all_endpoints(self, generator):
        """Test that all CRUD endpoints are generated"""
        options = {"method": "POST", "auth_required": True}

        await generator.generate_api_endpoint("Item", options)

        api_content = generator.write_file.call_args_list[0][0][1]

        # Check for all endpoints
        assert "@router.post" in api_content
        assert '@router.get("/")' in api_content  # List endpoint
        assert '@router.get("/{item_id}")' in api_content  # Get by ID
        assert '@router.get("/search/")' in api_content  # Search
        assert '@router.delete("/{item_id}")' in api_content  # Delete

    def test_generate_post_logic(self, generator):
        """Test POST method logic generation"""
        logic = generator._generate_post_logic("Product", auth_required=True)

        assert "existing = service.get_by_name(request.name)" in logic
        assert "HTTP_409_CONFLICT" in logic
        assert "data['created_by_id'] = current_user.id" in logic
        assert "result = service.create(data)" in logic
        assert 'logger.info(f"Created new Product with ID: {result.id}")' in logic

    def test_generate_put_logic(self, generator):
        """Test PUT method logic generation"""
        logic = generator._generate_put_logic("Product", auth_required=True)

        assert "data = request.dict(exclude_unset=True)" in logic
        assert "data['updated_by_id'] = current_user.id" in logic
        assert "resource_id = options.get('resource_id', 1)" in logic
        assert "HTTP_404_NOT_FOUND" in logic

    def test_generate_get_logic(self, generator):
        """Test GET method logic generation"""
        logic = generator._generate_get_logic("Product")

        assert "filters = {}" in logic
        assert "filters = request.dict(exclude_unset=True)" in logic
        assert "results = service.list(filters=filters)" in logic
        assert "No Product found" in logic

    def test_generate_default_logic(self, generator):
        """Test default method logic generation"""
        logic = generator._generate_default_logic("Product")

        assert "placeholder for Product business logic" in logic
        assert "result = service.get_by_id(1)" in logic
        assert "Product not found" in logic

    def test_generate_get_by_id_endpoint_with_auth(self, generator):
        """Test GET by ID endpoint generation with auth"""
        endpoint = generator._generate_get_by_id_endpoint("Order", auth_required=True)

        assert '@router.get("/{order_id}")' in endpoint
        assert "current_user = Depends(get_current_user)" in endpoint
        assert "current_user: Current authenticated user" in endpoint
        assert "if result.created_by_id != current_user.id" in endpoint
        assert "HTTP_403_FORBIDDEN" in endpoint

    def test_generate_get_by_id_endpoint_without_auth(self, generator):
        """Test GET by ID endpoint generation without auth"""
        endpoint = generator._generate_get_by_id_endpoint("Order", auth_required=False)

        assert "current_user = Depends(get_current_user)" not in endpoint
        assert "Check permissions if needed" not in endpoint
        assert "HTTP_403_FORBIDDEN" not in endpoint

    def test_generate_search_endpoint(self, generator):
        """Test search endpoint generation"""
        endpoint = generator._generate_search_endpoint("Product", auth_required=True)

        assert '@router.get("/search/")' in endpoint
        assert "q: str = Query(..., min_length=1" in endpoint
        assert "category: Optional[str] = Query(None" in endpoint
        assert "tags: Optional[List[str]] = Query(None" in endpoint
        assert "search_filters = {" in endpoint
        assert "results = service.search(" in endpoint
        assert "paginate(results, pagination)" in endpoint

    def test_generate_delete_endpoint_with_permissions(self, generator):
        """Test delete endpoint with permission checks"""
        endpoint = generator._generate_delete_endpoint("Article", auth_required=True)

        assert '@router.delete("/{article_id}")' in endpoint
        assert "resource = service.get_by_id(article_id)" in endpoint
        assert "if resource.created_by_id != current_user.id" in endpoint
        assert "permission to delete this resource" in endpoint
        assert "service.delete(article_id, soft_delete=True)" in endpoint

    def test_generate_service_content(self, generator):
        """Test service layer generation"""
        content = generator._generate_service_content("Product", {})

        # Check imports
        assert "from sqlalchemy.orm import Session" in content
        assert "from sqlalchemy import or_, and_" in content

        # Check class definition
        assert "class ProductService:" in content

        # Check all service methods
        assert "def get_by_id(self, product_id: int)" in content
        assert "def get_by_name(self, name: str)" in content
        assert "def list(self, filters:" in content
        assert "def search(self, filters:" in content
        assert "def create(self, data:" in content
        assert "def update(self, product_id:" in content
        assert "def delete(self, product_id:" in content
        assert "def get_stats(self)" in content

        # Check caching decorators
        assert "@cache_result(ttl=300)" in content
        assert '@invalidate_cache(pattern="product:*")' in content

        # Check soft delete logic
        assert "is_deleted == False" in content
        assert "soft_delete: bool = True" in content

    def test_generate_model_content(self, generator):
        """Test SQLAlchemy model generation"""
        content = generator._generate_model_content("Order", {})

        # Check imports
        assert "from sqlalchemy import (Column, Integer, String" in content
        assert "from sqlalchemy.dialects.postgresql import ARRAY" in content
        assert "from sqlalchemy.orm import relationship" in content

        # Check class definition
        assert "class Order(Base):" in content
        assert '__tablename__ = "orders"' in content

        # Check all fields
        assert "id = Column(Integer, primary_key=True" in content
        assert "name = Column(String(255)" in content
        assert "description = Column(Text" in content
        assert "tags = Column(ARRAY(String)" in content
        assert "metadata = Column(JSON" in content
        assert "is_active = Column(Boolean" in content
        assert "is_deleted = Column(Boolean" in content

        # Check timestamps
        assert "created_at = Column(DateTime" in content
        assert "updated_at = Column(DateTime" in content
        assert "deleted_at = Column(DateTime" in content

        # Check relationships
        assert 'created_by = relationship("User"' in content
        assert 'backref="created_orders"' in content

        # Check methods
        assert "def __repr__(self):" in content
        assert "def to_dict(self):" in content
        assert "def from_dict(cls, data: dict):" in content

    @pytest.mark.asyncio
    async def test_generate_cli_command(self, generator):
        """Test CLI command generation"""
        result = await generator.generate_cli_command("test", {})

        assert result["created_files"] == []
        assert "Complete CLI implementation" in result["next_steps"]

    def test_string_replacements_work_correctly(self, generator):
        """Test that {name} placeholders are replaced correctly"""
        logic = generator._generate_post_logic("TestEntity", auth_required=False)

        # Should not contain {name} placeholder anymore
        assert "{name}" not in logic
        assert "TestEntity" in logic
        assert 'f"TestEntity with name' in logic

    def test_f_string_formatting(self, generator):
        """Test that f-strings are properly formatted"""
        endpoint = generator._generate_get_by_id_endpoint("Item", auth_required=False)

        # Check for proper f-string formatting
        assert "{item_id}" in endpoint  # Should be properly escaped
        assert 'logger.info(f"Retrieved Item with ID: {item_id}")' in endpoint
        assert 'f"Error retrieving Item {item_id}: {str(e)}"' in endpoint

    @pytest.mark.asyncio
    async def test_file_paths_are_correct(self, generator):
        """Test that generated file paths are correct"""
        generator.get_source_directory = MagicMock(return_value=Path("/project/src"))

        await generator.generate_api_endpoint("Customer", {})

        # Check the paths passed to write_file
        calls = generator.write_file.call_args_list
        assert calls[0][0][0] == Path("/project/src/api/customer.py")
        assert calls[1][0][0] == Path("/project/src/services/customer.py")
        assert calls[2][0][0] == Path("/project/src/models/customer.py")

    def test_generated_code_has_proper_imports(self, generator):
        """Test that generated code has all necessary imports"""
        content = generator._generate_service_content("Product", {})

        required_imports = [
            "from typing import List, Optional, Dict, Any",
            "from sqlalchemy.orm import Session",
            "from sqlalchemy import or_, and_",
            "from datetime import datetime",
            "import logging",
            "from ..models.product import Product as ProductModel",
            "from ..schemas.product import ProductCreate, ProductUpdate",
            "from ..utils.cache import cache_result, invalidate_cache",
        ]

        for import_stmt in required_imports:
            assert import_stmt in content, f"Missing import: {import_stmt}"

    def test_error_handling_in_endpoints(self, generator):
        """Test that proper error handling is included"""
        endpoint = generator._generate_search_endpoint("Item", auth_required=False)

        assert "try:" in endpoint
        assert "except Exception as e:" in endpoint
        assert "logger.error(" in endpoint
        assert "HTTP_500_INTERNAL_SERVER_ERROR" in endpoint
        assert '"Search failed"' in endpoint


class TestPythonGeneratorEdgeCases:
    """Test edge cases and error scenarios"""

    @pytest.fixture
    def generator(self):
        """Create a generator with mocked dependencies"""
        generator = PythonGeneratorForTesting()
        generator.get_source_directory = MagicMock(return_value=Path("/test"))
        generator.generate_file_header = MagicMock(return_value="# Header\n")
        generator.write_file = MagicMock(return_value={"path": "test.py", "size": 100})
        return generator

    @pytest.mark.asyncio
    async def test_special_characters_in_name(self, generator):
        """Test handling of special characters in entity names"""
        # Should handle names with underscores, numbers, etc.
        await generator.generate_api_endpoint("User_Profile_2", {})

        api_content = generator.write_file.call_args_list[0][0][1]
        assert "user_profile_2" in api_content  # Should be lowercased
        assert "User_Profile_2" in api_content  # Should preserve original for class names

    @pytest.mark.asyncio
    async def test_empty_options(self, generator):
        """Test generation with empty options dict"""
        await generator.generate_api_endpoint("Product", {})

        # Should use defaults
        api_content = generator.write_file.call_args_list[0][0][1]
        assert "@router.get" in api_content  # Default method
        assert "from ..auth import get_current_user" in api_content  # Default auth=True

    def test_sql_injection_prevention_in_service(self, generator):
        """Test that generated service code prevents SQL injection"""
        content = generator._generate_service_content("Product", {})

        # Should use SQLAlchemy ORM methods, not raw SQL
        assert ".filter(" in content
        assert ".query(" in content
        assert "ilike(" in content  # Parameterized queries
        # Should NOT contain raw SQL
        assert "execute(" not in content
        assert "raw(" not in content
