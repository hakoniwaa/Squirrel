#!/usr/bin/env python3
"""
Integration tests for Python Template Generator
Tests actual file generation and content validation
"""

import ast
import shutil
import tempfile
from pathlib import Path
from unittest.mock import MagicMock

import pytest

from tests.helpers.test_python_generator_base import PythonGeneratorForTesting


class TestPythonGeneratorIntegration:
    """Integration tests with real file system operations"""

    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory for testing"""
        temp_dir = tempfile.mkdtemp()
        yield Path(temp_dir)
        # Cleanup
        shutil.rmtree(temp_dir)

    @pytest.fixture
    def generator(self, temp_dir):
        """Create a generator with real file operations"""
        generator = PythonGeneratorForTesting()

        # Create source directory structure
        src_dir = temp_dir / "src"
        (src_dir / "api").mkdir(parents=True)
        (src_dir / "services").mkdir(parents=True)
        (src_dir / "models").mkdir(parents=True)

        # Mock only the source directory method
        generator.get_source_directory = MagicMock(return_value=src_dir)
        generator.generate_file_header = MagicMock(
            return_value="#!/usr/bin/env python3\n# Generated by coder-mcp\n\n"
        )

        # Patch the base class write_file to actually write files
        def mock_write_file(path: Path, content: str):
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(content)
            return {
                "path": str(path),
                "purpose": f"Generated {generator.get_language_name()} file",
                "language": generator.get_language_name(),
                "size": len(content),
            }

        generator.write_file = mock_write_file

        return generator

    @pytest.mark.asyncio
    async def test_complete_api_generation(self, generator, temp_dir):
        """Test complete API generation with file verification"""
        options = {"method": "POST", "auth_required": True}

        await generator.generate_api_endpoint("Product", options)

        # Verify files were created
        api_file = temp_dir / "src" / "api" / "product.py"
        service_file = temp_dir / "src" / "services" / "product.py"
        model_file = temp_dir / "src" / "models" / "product.py"

        assert api_file.exists()
        assert service_file.exists()
        assert model_file.exists()

        # Verify API file content
        api_content = api_file.read_text()
        assert "class ProductRequest(BaseModel):" in api_content
        assert "class ProductResponse(BaseModel):" in api_content
        assert "@router.post" in api_content
        assert "async def post_product(" in api_content

        # Verify service file content
        service_content = service_file.read_text()
        assert "class ProductService:" in service_content
        assert "def get_by_id(self, product_id: int)" in service_content
        assert "@cache_result(ttl=300)" in service_content

        # Verify model file content
        model_content = model_file.read_text()
        assert "class Product(Base):" in model_content
        assert '__tablename__ = "products"' in model_content

    @pytest.mark.asyncio
    async def test_generated_code_syntax(self, generator, temp_dir):
        """Test that generated code has valid Python syntax"""
        await generator.generate_api_endpoint("User", {"method": "GET"})

        # Check each generated file for syntax errors
        for file_type in ["api", "services", "models"]:
            file_path = temp_dir / "src" / file_type / "user.py"
            content = file_path.read_text()

            # This will raise SyntaxError if invalid
            try:
                ast.parse(content)
            except SyntaxError as e:
                pytest.fail(f"Syntax error in {file_type}/user.py: {e}")

    @pytest.mark.asyncio
    async def test_different_http_methods(self, generator, temp_dir):
        """Test generation for different HTTP methods"""
        methods = ["GET", "POST", "PUT", "DELETE", "PATCH"]

        for method in methods:
            name = f"Test{method}"
            options = {"method": method, "auth_required": False}

            await generator.generate_api_endpoint(name, options)

            api_file = temp_dir / "src" / "api" / f"test{method.lower()}.py"
            content = api_file.read_text()

            # Verify correct method decorator
            assert f"@router.{method.lower()}" in content
            assert f"async def {method.lower()}_test{method.lower()}(" in content

    @pytest.mark.asyncio
    async def test_auth_variations(self, generator, temp_dir):
        """Test auth required vs not required variations"""
        # With auth
        await generator.generate_api_endpoint(
            "SecureResource", {"method": "POST", "auth_required": True}
        )

        secure_api = (temp_dir / "src" / "api" / "secureresource.py").read_text()
        assert "from ..auth import get_current_user" in secure_api
        assert "current_user = Depends(get_current_user)" in secure_api

        # Without auth
        await generator.generate_api_endpoint(
            "PublicResource", {"method": "POST", "auth_required": False}
        )

        public_api = (temp_dir / "src" / "api" / "publicresource.py").read_text()
        assert "from ..auth import get_current_user" not in public_api
        assert "current_user = Depends(get_current_user)" not in public_api

    @pytest.mark.asyncio
    async def test_import_organization(self, generator, temp_dir):
        """Test that imports are properly organized"""
        await generator.generate_api_endpoint("Order", {})

        api_file = temp_dir / "src" / "api" / "order.py"
        content = api_file.read_text()

        # Check import order (standard library, third party, local)
        lines = content.split("\n")
        import_section = []
        in_imports = False

        for line in lines:
            if line.startswith("from") or line.startswith("import"):
                in_imports = True
                import_section.append(line)
            elif in_imports and line.strip() == "":
                continue
            elif in_imports:
                break

        # Verify standard library imports come first
        assert any("from typing import" in imp for imp in import_section[:5])
        assert any("from datetime import" in imp for imp in import_section[:5])

    @pytest.mark.asyncio
    async def test_complex_entity_names(self, generator, temp_dir):
        """Test handling of complex entity names"""
        names = ["UserProfile", "OrderItem", "ProductCategory", "CustomerOrder", "InventoryItem"]

        for name in names:
            await generator.generate_api_endpoint(name, {"method": "GET"})

            # Check files are created with correct naming
            api_file = temp_dir / "src" / "api" / f"{name.lower()}.py"
            assert api_file.exists()

            content = api_file.read_text()
            assert f"class {name}Request" in content
            assert f"class {name}Response" in content
            assert f"/{name.lower()}" in content  # URL path

    @pytest.mark.asyncio
    async def test_service_layer_completeness(self, generator, temp_dir):
        """Test that service layer has all CRUD operations"""
        await generator.generate_api_endpoint("Article", {})

        service_file = temp_dir / "src" / "services" / "article.py"
        content = service_file.read_text()

        # Check all CRUD methods
        crud_methods = [
            "def get_by_id(",
            "def get_by_name(",
            "def list(",
            "def search(",
            "def create(",
            "def update(",
            "def delete(",
            "def get_stats(",
        ]

        for method in crud_methods:
            assert method in content, f"Missing method: {method}"

    @pytest.mark.asyncio
    async def test_model_relationships(self, generator, temp_dir):
        """Test that model includes proper relationships"""
        await generator.generate_api_endpoint("BlogPost", {})

        model_file = temp_dir / "src" / "models" / "blogpost.py"
        content = model_file.read_text()

        # Check foreign keys
        assert "created_by_id = Column(Integer, ForeignKey" in content
        assert "updated_by_id = Column(Integer, ForeignKey" in content

        # Check relationships
        assert 'created_by = relationship("User"' in content
        assert 'backref="created_blogposts"' in content

        # Check example relationships in comments
        assert "# Example: One-to-many relationship" in content
        assert "# Example: Many-to-many relationship" in content

    @pytest.mark.asyncio
    async def test_pagination_support(self, generator, temp_dir):
        """Test that pagination is properly implemented"""
        await generator.generate_api_endpoint("Product", {})

        api_content = (temp_dir / "src" / "api" / "product.py").read_text()
        service_content = (temp_dir / "src" / "services" / "product.py").read_text()

        # API should have pagination params
        assert "PaginationParams" in api_content
        assert "pagination: PaginationParams = Depends()" in api_content
        assert "paginate(results, pagination)" in api_content

        # Service should support offset/limit
        assert "offset: int = 0" in service_content
        assert "limit: int = 100" in service_content
        assert ".offset(offset).limit(limit)" in service_content

    @pytest.mark.asyncio
    async def test_error_handling_completeness(self, generator, temp_dir):
        """Test comprehensive error handling"""
        await generator.generate_api_endpoint("Payment", {})

        api_file = temp_dir / "src" / "api" / "payment.py"
        content = api_file.read_text()

        # Check for different HTTP status codes
        assert "HTTP_400_BAD_REQUEST" in content
        assert "HTTP_404_NOT_FOUND" in content
        assert "HTTP_409_CONFLICT" in content
        assert "HTTP_500_INTERNAL_SERVER_ERROR" in content

        # Check for try/except blocks
        assert content.count("try:") >= 4  # Multiple endpoints
        assert content.count("except HTTPException:") >= 4
        assert content.count("except Exception as e:") >= 4

    @pytest.mark.asyncio
    async def test_caching_implementation(self, generator, temp_dir):
        """Test that caching is properly implemented"""
        await generator.generate_api_endpoint("Product", {})

        service_file = temp_dir / "src" / "services" / "product.py"
        content = service_file.read_text()

        # Check cache decorators
        assert "@cache_result(ttl=300)" in content
        assert '@invalidate_cache(pattern="product:*")' in content

        # Cache should be on read operations
        assert content.find("@cache_result") < content.find("def get_by_id")

        # Cache invalidation on write operations
        assert '@invalidate_cache(pattern="product:*")' in content
        assert content.find("@invalidate_cache") < content.find("def create")
        assert content.find("@invalidate_cache") < content.find("def update")
        assert content.find("@invalidate_cache") < content.find("def delete")
