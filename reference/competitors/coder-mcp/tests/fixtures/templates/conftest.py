#!/usr/bin/env python3
"""
Pytest configuration for template generator tests
Provides shared fixtures and test utilities
"""

import tempfile
import shutil
from pathlib import Path
from unittest.mock import MagicMock
from typing import Dict, Any
import pytest


@pytest.fixture
def mock_base_generator():
    """Create a mock base generator with common methods"""
    mock = MagicMock()
    mock.get_source_directory = MagicMock(return_value=Path("/test/src"))
    mock.generate_file_header = MagicMock(
        return_value="#!/usr/bin/env python3\n# Generated by coder-mcp\n\n"
    )
    mock.write_file = MagicMock(return_value={"path": "test.py", "size": 100})
    return mock


@pytest.fixture
def temp_workspace():
    """Create a temporary workspace with proper structure"""
    temp_dir = tempfile.mkdtemp()
    workspace = Path(temp_dir)

    # Create standard project structure
    (workspace / "src").mkdir()
    (workspace / "src" / "api").mkdir()
    (workspace / "src" / "models").mkdir()
    (workspace / "src" / "services").mkdir()
    (workspace / "src" / "schemas").mkdir()
    (workspace / "src" / "utils").mkdir()
    (workspace / "tests").mkdir()
    (workspace / "tests" / "unit").mkdir()
    (workspace / "tests" / "integration").mkdir()

    # Create __init__.py files
    for dir_path in workspace.rglob("*/"):
        if dir_path.name not in [".git", "__pycache__"]:
            (dir_path / "__init__.py").touch()

    yield workspace

    # Cleanup
    shutil.rmtree(temp_dir)


@pytest.fixture
def sample_options() -> Dict[str, Any]:
    """Provide sample options for template generation"""
    return {
        "method": "POST",
        "auth_required": True,
        "include_tests": True,
        "include_docs": True,
    }


@pytest.fixture
def mock_file_writer():
    """Mock file writer that captures written content"""
    written_files = {}

    async def write_file(path: Path, content: str):
        written_files[str(path)] = content

    write_file.written_files = written_files
    write_file.reset = lambda: written_files.clear()

    return write_file


@pytest.fixture
def verify_python_syntax():
    """Fixture that provides a function to verify Python syntax"""
    import ast

    def verify(code: str, filename: str = "<generated>"):
        """Verify that the code has valid Python syntax"""
        try:
            ast.parse(code, filename=filename)
            return True
        except SyntaxError as e:
            pytest.fail(f"Syntax error in {filename}: {e}")
            return False

    return verify


@pytest.fixture
def assert_imports_present():
    """Fixture to verify required imports are present"""

    def assert_imports(content: str, required_imports: list):
        """Assert that all required imports are present in the content"""
        for import_stmt in required_imports:
            assert import_stmt in content, f"Missing import: {import_stmt}"

    return assert_imports


@pytest.fixture
def assert_no_placeholders():
    """Fixture to verify no template placeholders remain"""

    def assert_clean(content: str):
        """Assert that no template placeholders remain in generated content"""
        # Check for common template placeholder patterns
        assert "{name}" not in content, "Found unreplaced {name} placeholder"
        assert "{{name}}" not in content, "Found unreplaced {{name}} placeholder"
        assert "{method}" not in content, "Found unreplaced {method} placeholder"
        assert "TODO" not in content, "Found TODO in generated code"
        assert "FIXME" not in content, "Found FIXME in generated code"

    return assert_clean


# Shared test data
SAMPLE_ENTITIES = [
    "User",
    "Product",
    "Order",
    "Customer",
    "Invoice",
    "Category",
    "BlogPost",
    "Comment",
    "UserProfile",
    "ShoppingCart",
]

SAMPLE_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE"]

EXPECTED_SERVICE_METHODS = [
    "get_by_id",
    "get_by_name",
    "list",
    "search",
    "create",
    "update",
    "delete",
    "get_stats",
]

EXPECTED_MODEL_FIELDS = [
    "id",
    "name",
    "description",
    "category",
    "tags",
    "metadata",
    "is_active",
    "is_deleted",
    "created_at",
    "updated_at",
    "deleted_at",
    "created_by_id",
    "updated_by_id",
]
