/**
 * AI Discovery Integration Tests
 *
 * Tests the full workflow: session ends → extract discoveries → call Claude →
 * store refined discoveries → apply to project.yaml
 *
 * This validates that AI-enhanced discovery extraction works end-to-end
 */

import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { AIDiscoveryService } from "@/application/services/AIDiscoveryService";
import { RefinedDiscoveryStorage } from "@/infrastructure/storage/refined-discovery-storage";
import type {
  IAIClient,
  DiscoveryRefinementRequest,
  DiscoveryRefinementResponse,
} from "@/application/ports/IAIClient";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";

describe.skip("AI Discovery Integration - DEFERRED (Phase 6)", () => {
  let discoveryService: AIDiscoveryService;
  let discoveryStorage: RefinedDiscoveryStorage;
  let mockAIClient: IAIClient;
  let testDir: string;
  let dbPath: string;

  beforeEach(async () => {
    // Create temporary test directory
    testDir = await fs.mkdtemp(
      path.join(os.tmpdir(), "kioku-ai-discovery-test-"),
    );
    dbPath = path.join(testDir, "test.db");

    // Create mock AI client
    mockAIClient = {
      async refineDiscovery(
        request: DiscoveryRefinementRequest,
      ): Promise<DiscoveryRefinementResponse> {
        // Mock Claude API response
        const content = request.rawContent;

        // Simulate AI refinement
        if (content.includes("authentication")) {
          return {
            type: "architectural-pattern",
            confidence: 0.85,
            description: "JWT-based authentication with refresh tokens",
            evidence: content.substring(0, 100),
            suggestedModule: "auth",
            tokensUsed: 150,
            costUsd: 0.0015,
            processingTimeMs: 1200,
          };
        } else if (content.includes("database")) {
          return {
            type: "tech-stack",
            confidence: 0.92,
            description: "PostgreSQL with Prisma ORM",
            evidence: content.substring(0, 100),
            suggestedModule: "data",
            tokensUsed: 120,
            costUsd: 0.0012,
            processingTimeMs: 1000,
          };
        } else {
          return {
            type: "feature",
            confidence: 0.45, // Below threshold
            description: "Generic feature",
            evidence: content,
            suggestedModule: "unknown",
            tokensUsed: 80,
            costUsd: 0.0008,
            processingTimeMs: 800,
          };
        }
      },

      async checkHealth() {
        return { available: true, quotaRemaining: 1000000 };
      },

      async estimateCost(discoveryCount: number) {
        return {
          estimatedTokens: discoveryCount * 100,
          estimatedCostUsd: discoveryCount * 0.001,
        };
      },
    };

    // Initialize storage
    discoveryStorage = new RefinedDiscoveryStorage(dbPath);

    // Initialize service
    discoveryService = new AIDiscoveryService(mockAIClient);
  });

  afterEach(async () => {
    // Clean up test directory
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  describe("T094: Full workflow - session ends → extract → refine → store", () => {
    it("should refine discoveries and store those above confidence threshold", async () => {
      const sessionContext = {
        sessionId: "session-123",
        conversationMessages: [
          "How do we handle authentication in this project?",
          "We use JWT tokens with refresh token rotation",
          "The auth service validates tokens on every request",
        ],
        filesAccessed: [
          "/project/src/auth/jwt-handler.ts",
          "/project/src/auth/refresh-token.ts",
        ],
      };

      const rawDiscoveries = [
        "JWT-based authentication with refresh tokens and rotation",
        "PostgreSQL database with Prisma ORM for data persistence",
        "Some random low confidence discovery",
      ];

      // Refine discoveries
      const refinedDiscoveries =
        await discoveryService.refineSessionDiscoveries(
          rawDiscoveries,
          sessionContext,
        );

      // Should filter out low confidence discoveries
      expect(refinedDiscoveries.length).toBe(2);

      // Check authentication discovery
      const authDiscovery = refinedDiscoveries.find(
        (d) => d.type === "architectural-pattern",
      );
      expect(authDiscovery).toBeDefined();
      expect(authDiscovery!.confidence).toBeGreaterThanOrEqual(0.6);
      expect(authDiscovery!.description).toContain("JWT");
      expect(authDiscovery!.suggestedModule).toBe("auth");
      expect(authDiscovery!.tokensUsed).toBeGreaterThan(0);

      // Check database discovery
      const dbDiscovery = refinedDiscoveries.find(
        (d) => d.type === "tech-stack",
      );
      expect(dbDiscovery).toBeDefined();
      expect(dbDiscovery!.confidence).toBeGreaterThanOrEqual(0.6);
      expect(dbDiscovery!.description).toContain("PostgreSQL");
      expect(dbDiscovery!.suggestedModule).toBe("data");

      // Store refined discoveries
      for (const discovery of refinedDiscoveries) {
        await discoveryStorage.save({
          sessionId: sessionContext.sessionId,
          rawContent:
            rawDiscoveries.find((r) =>
              r
                .toLowerCase()
                .includes(discovery.description.toLowerCase().split(" ")[0]),
            ) || rawDiscoveries[0],
          refinedContent: discovery.description,
          type: discovery.type,
          confidence: discovery.confidence,
          supportingEvidence: discovery.evidence,
          suggestedModule: discovery.suggestedModule || undefined,
          aiModel: "claude-3-sonnet-20240229",
          tokensUsed: discovery.tokensUsed,
          processingTime: discovery.processingTimeMs,
          accepted: false,
          appliedAt: undefined,
        });
      }

      // Verify storage
      const storedDiscoveries =
        await discoveryStorage.findBySessionId("session-123");
      expect(storedDiscoveries.length).toBe(2);
      expect(storedDiscoveries.every((d) => d.confidence >= 0.6)).toBe(true);
    });

    it("should redact sensitive data before sending to AI", async () => {
      const sessionContext = {
        sessionId: "session-456",
        conversationMessages: [
          "The API key is sk-1234567890abcdefghijklmnopqrstuvwxyz",
          "Database password: secretpass123",
        ],
        filesAccessed: ["/project/config/secrets.ts"],
      };

      const rawDiscoveries = [
        "API integration using key sk-1234567890abcdefghijklmnopqrstuvwxyz for authentication",
      ];

      // Mock to capture what was sent to AI
      let sentToAI = "";
      mockAIClient.refineDiscovery = async (
        request: DiscoveryRefinementRequest,
      ) => {
        sentToAI = request.rawContent;
        return {
          type: "integration",
          confidence: 0.75,
          description: "External API integration",
          evidence: request.rawContent,
          suggestedModule: "external",
          tokensUsed: 100,
          costUsd: 0.001,
          processingTimeMs: 900,
        };
      };

      await discoveryService.refineSessionDiscoveries(
        rawDiscoveries,
        sessionContext,
      );

      // Verify sensitive data was redacted
      expect(sentToAI).not.toContain("sk-1234567890abcdefghijklmnopqrstuvwxyz");
      expect(sentToAI).toContain("[REDACTED:API_KEY]");
    });

    it("should handle AI client errors gracefully", async () => {
      const sessionContext = {
        sessionId: "session-error",
        conversationMessages: ["Test message"],
        filesAccessed: [],
      };

      const rawDiscoveries = ["Test discovery"];

      // Mock AI client to throw error
      mockAIClient.refineDiscovery = async () => {
        throw new Error("API rate limit exceeded");
      };

      // Should throw the error (fallback logic would be in a higher-level service)
      await expect(
        discoveryService.refineSessionDiscoveries(
          rawDiscoveries,
          sessionContext,
        ),
      ).rejects.toThrow("API rate limit exceeded");
    });

    it("should track AI usage metrics", async () => {
      const sessionContext = {
        sessionId: "session-metrics",
        conversationMessages: ["Testing metrics"],
        filesAccessed: [],
      };

      const rawDiscoveries = ["JWT authentication system"];

      const refinedDiscoveries =
        await discoveryService.refineSessionDiscoveries(
          rawDiscoveries,
          sessionContext,
        );

      expect(refinedDiscoveries.length).toBeGreaterThan(0);

      const discovery = refinedDiscoveries[0];
      expect(discovery.tokensUsed).toBeGreaterThan(0);
      expect(discovery.costUsd).toBeGreaterThan(0);
      expect(discovery.processingTimeMs).toBeGreaterThan(0);

      // Store and verify metrics persisted
      await discoveryStorage.save({
        sessionId: sessionContext.sessionId,
        rawContent: rawDiscoveries[0],
        refinedContent: discovery.description,
        type: discovery.type,
        confidence: discovery.confidence,
        supportingEvidence: discovery.evidence,
        suggestedModule: discovery.suggestedModule || undefined,
        aiModel: "claude-3-sonnet-20240229",
        tokensUsed: discovery.tokensUsed,
        processingTime: discovery.processingTimeMs,
        accepted: false,
        appliedAt: undefined,
      });

      const stored = await discoveryStorage.findBySessionId("session-metrics");
      expect(stored[0].tokensUsed).toBe(discovery.tokensUsed);
      expect(stored[0].processingTime).toBe(discovery.processingTimeMs);
    });

    it("should check API health before processing", async () => {
      const health = await discoveryService.checkAPIHealth();

      expect(health.available).toBe(true);
      expect(health.quotaRemaining).toBeGreaterThan(0);
    });

    it("should estimate refinement cost", async () => {
      const estimate = await discoveryService.estimateRefinementCost(10);

      expect(estimate.estimatedTokens).toBe(1000);
      expect(estimate.estimatedCostUsd).toBe(0.01);
    });
  });
});
